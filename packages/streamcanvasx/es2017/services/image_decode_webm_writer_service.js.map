{"version":3,"sources":["./src/services/image_decode_webm_writer_service.ts"],"sourcesContent":["import WebMWriter from 'webm-writer';\n\nclass ImageDecoderService {\n  private imageDecoderProcess: ImageDecoder;\n   constructor() {\n    console.log('--');\n   }\n   async createImageDecoder(imageByteStream: ImageBufferSource): Promise<ImageDecoder> {\n  /*\n  ImageDecoder 是一个Web API，它提供了更多对解码图像过程的控制。\n  可以使用它将图像数据（如 ArrayBuffer 或 Blob）解码成可以绘制到 Canvas 上的格式。\n  */\n    const imageDecoder = new ImageDecoder({\n        data: imageByteStream,\n        type: 'image/gif',\n    });\n\n\n    await imageDecoder.tracks.ready;\n    await imageDecoder.completed;\n\n    this.imageDecoderProcess = imageDecoder;\n\n    return imageDecoder;\n    }\n\n    /*\n\n    除了使用 FileReader 的 readAsArrayBuffer 方法外，\n    还可以使用 Blob.arrayBuffer() (File 对象就是一个 Blob 对象) 方法来获得一个 Promise，\n    该 Promise 解析为表示 Blob 数据的 ArrayBuffer。\n\n    */\n    async blobToArrayBuffer(file: Blob) {\n        const arraybuffer = await file.arrayBuffer();\n        return arraybuffer;\n    }\n\n    async fetchImageByteStream(gifURL: string) {\n        const response = await fetch(gifURL);\n        return response.body!;\n    }\n    async decodeGifToWebM(imageDecoder: ImageDecoder) {\n        const { frameCount } = imageDecoder.tracks.selectedTrack!;\n        const { image: headFrame } = await imageDecoder.decode({ frameIndex: 0 });\n        const frameDuration = headFrame.duration! / 1000;\n\n        console.log('--输出帧日志--');\n        console.log({ headFrame, frameCount, frameDuration });\n\n\n        const canvas = document.createElement('canvas');\n        // codedWidth ，codedHeight代表视频帧的编码高度和宽度，这是帧原始的像素维度。\n        canvas.width = headFrame.codedWidth;\n        canvas.height = headFrame.codedHeight;\n        const canvasContext = canvas.getContext('2d')!;\n\n\n        const videoWriter = new WebMWriter({\n            quality: 1, // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (VP8L lossless) is not supported\n            fileWriter: null, // FileWriter in order to stream to a file instead of buffering to memory (optional)\n            fd: null, // Node.js file handle to write to instead of buffering to memory (optional)\n\n            // You must supply one of:\n            frameDuration, // Duration of frames in milliseconds\n            frameRate: 1000 / frameDuration, // Number of frames per second\n\n            transparent: true, // True if an alpha channel should be included in the video\n            alphaQuality: 1, // Allows you to set the quality level of the alpha channel separately.\n            // If not specified this defaults to the same value as `quality`.\n        });\n\n        const writeVideoFrame = async (frameIndex: number = 0) => {\n            if (frameIndex >= frameCount) return;\n\n            const result = await imageDecoder.decode({ frameIndex });\n            canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n            canvasContext.drawImage(result.image, 0, 0);\n            videoWriter.addFrame(canvas);\n\n            await writeVideoFrame(frameIndex + 1);\n        };\n\n        await writeVideoFrame();\n\n        const webMBlob: Blob = await videoWriter.complete();\n        return URL.createObjectURL(webMBlob);\n    }\n\n\n    async getImageDataByByUrl(options: {\n        imgUrl: string;\n    }) {\n        const { imgUrl } = options;\n        const imageData = await this.fetchImageByteStream(imgUrl);\n        return imageData;\n    }\n\n    async getImageDataByFile(file: Blob) {\n        let data = this.blobToArrayBuffer(file);\n        return data;\n    }\n\n    async decoderByData(data: ImageBufferSource) {\n        const startTime = performance.now();\n        const imageDecoder = await this.createImageDecoder(data);\n    }\n\n\n    async getFrameResultByFrameIndex(options: ImageDecodeOptions, imageDecoderPorocss: ImageDecoder): Promise<ImageDecodeResult> {\n        let { frameIndex } = options;\n        const result = await imageDecoderPorocss.decode({ frameIndex });\n        return result;\n    }\n\n    async compose1(options: {\n        imgUrl: string;\n    }) {\n        let imgData = await this.getImageDataByByUrl(options);\n        const startTime = new Date();\n        let imageDecoder = await this.createImageDecoder(imgData);\n        const videoBlobURL = await this.decodeGifToWebM(imageDecoder);\n        const endTime = new Date();\n        const duration_time = (endTime.getTime() - startTime.getTime()) / 1000;\n\n        console.log(`转码用时${duration_time} 秒`);\n        return videoBlobURL;\n    }\n\n    async compose2(options: {\n        imgUrl: string;\n    }) {\n        let imgData = await this.getImageDataByByUrl(options);\n        const startTime = new Date();\n        let imageDecoder = await this.createImageDecoder(imgData);\n\n        let result = this.getFrameResultByFrameIndex({ frameIndex: 0 }, imageDecoder);\n    }\n\n    async renderCanvas(options: {\n        imgUrl: string;\n    }) {\n        const { imgUrl } = options;\n        const imageByteStream = await this.fetchImageByteStream(imgUrl);\n        const imageDecoder = await this.createImageDecoder(imageByteStream);\n\n\n        const { frameCount } = imageDecoder.tracks.selectedTrack!;\n        const { image: headFrame } = await imageDecoder.decode({ frameIndex: 0 });\n        const frameDuration = headFrame.duration! / 1000;\n    }\n}\n\n\nexport { ImageDecoderService };"],"names":["WebMWriter","ImageDecoderService","createImageDecoder","imageByteStream","imageDecoder","ImageDecoder","data","type","tracks","ready","completed","imageDecoderProcess","blobToArrayBuffer","file","arraybuffer","arrayBuffer","fetchImageByteStream","gifURL","response","fetch","body","decodeGifToWebM","frameCount","selectedTrack","image","headFrame","decode","frameIndex","frameDuration","duration","console","log","canvas","document","createElement","width","codedWidth","height","codedHeight","canvasContext","getContext","videoWriter","quality","fileWriter","fd","frameRate","transparent","alphaQuality","writeVideoFrame","result","clearRect","drawImage","addFrame","webMBlob","complete","URL","createObjectURL","getImageDataByByUrl","options","imgUrl","imageData","getImageDataByFile","decoderByData","startTime","performance","now","getFrameResultByFrameIndex","imageDecoderPorocss","compose1","imgData","Date","videoBlobURL","endTime","duration_time","getTime","compose2","renderCanvas","constructor"],"mappings":"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"}