{"version":3,"sources":["./src/services/image-decoder-wem-writter.ts"],"sourcesContent":["// @ts-ignore\nimport WebMWriter from 'webm-writer';\n\nconst fetchImageByteStream = async (gifURL: string) => {\n    const response = await fetch(gifURL);\n    return response.body!;\n};\n\nconst createImageDecoder = async (imageByteStream: ReadableStream<Uint8Array>) => {\n    const imageDecoder = new ImageDecoder({\n        data: imageByteStream,\n        type: 'image/gif',\n    });\n\n    await imageDecoder.tracks.ready;\n    await imageDecoder.completed;\n    return imageDecoder;\n};\n\n\nconst decodeGifToWebM = async (imageDecoder: ImageDecoder) => {\n    const { frameCount } = imageDecoder.tracks.selectedTrack!;\n    const { image: headFrame } = await imageDecoder.decode({ frameIndex: 0 });\n    const frameDuration = headFrame.duration! / 1000;\n\n    console.log({ headFrame, frameCount, frameDuration });\n\n    const canvas = document.createElement('canvas');\n    canvas.width = headFrame.codedWidth;\n    canvas.height = headFrame.codedHeight;\n    const canvasContext = canvas.getContext('2d')!;\n\n    const videoWriter = new WebMWriter({\n        quality: 1, // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (VP8L lossless) is not supported\n        fileWriter: null, // FileWriter in order to stream to a file instead of buffering to memory (optional)\n        fd: null, // Node.js file handle to write to instead of buffering to memory (optional)\n\n        // You must supply one of:\n        frameDuration, // Duration of frames in milliseconds\n        frameRate: 1000 / frameDuration, // Number of frames per second\n\n        transparent: true, // True if an alpha channel should be included in the video\n        alphaQuality: 1, // Allows you to set the quality level of the alpha channel separately.\n        // If not specified this defaults to the same value as `quality`.\n    });\n\n    const writeVideoFrame = async (frameIndex: number = 0) => {\n        if (frameIndex >= frameCount) return;\n\n        const result = await imageDecoder.decode({ frameIndex });\n        canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n        canvasContext.drawImage(result.image, 0, 0);\n        videoWriter.addFrame(canvas);\n\n        await writeVideoFrame(frameIndex + 1);\n    };\n\n    await writeVideoFrame();\n\n    const webMBlob: Blob = await videoWriter.complete();\n    return URL.createObjectURL(webMBlob);\n};\n\n\nexport function setupImageDecodeWriteWebm(options: {\n    inputGif: HTMLImageElement;\n    button: HTMLButtonElement;\n    video: HTMLVideoElement;\n    time: HTMLSpanElement;\n}) {\n    const startTranscode = async () => {\n        options.time.innerText = '开始转码...';\n        const startTime = new Date();\n\n        const image = options.inputGif;\n        const imageByteStream = await fetchImageByteStream(image.src);\n        const imageDecoder = await createImageDecoder(imageByteStream);\n        const webmBlobURL = await decodeGifToWebM(imageDecoder);\n\n        options.video.src = webmBlobURL;\n\n        const endTime = new Date();\n        const duration = (endTime.getTime() - startTime.getTime()) / 1000;\n        options.time.innerText = `转码完成，用时 ${duration}s`;\n    };\n\n    options.button.addEventListener('click', startTranscode, false);\n}"],"names":["WebMWriter","fetchImageByteStream","gifURL","response","fetch","body","createImageDecoder","imageByteStream","imageDecoder","ImageDecoder","data","type","tracks","ready","completed","decodeGifToWebM","frameCount","selectedTrack","image","headFrame","decode","frameIndex","frameDuration","duration","console","log","canvas","document","createElement","width","codedWidth","height","codedHeight","canvasContext","getContext","videoWriter","quality","fileWriter","fd","frameRate","transparent","alphaQuality","writeVideoFrame","result","clearRect","drawImage","addFrame","webMBlob","complete","URL","createObjectURL","setupImageDecodeWriteWebm","options","startTranscode","time","innerText","startTime","Date","inputGif","src","webmBlobURL","video","endTime","getTime","button","addEventListener"],"mappings":"AAAA,aAAa;AACb,OAAOA,gBAAgB,cAAc;AAErC,MAAMC,uBAAuB,OAAOC,SAAmB;IACnD,MAAMC,WAAW,MAAMC,MAAMF;IAC7B,OAAOC,SAASE,IAAI;AACxB;AAEA,MAAMC,qBAAqB,OAAOC,kBAAgD;IAC9E,MAAMC,eAAe,IAAIC,aAAa;QAClCC,MAAMH;QACNI,MAAM;IACV;IAEA,MAAMH,aAAaI,MAAM,CAACC,KAAK;IAC/B,MAAML,aAAaM,SAAS;IAC5B,OAAON;AACX;AAGA,MAAMO,kBAAkB,OAAOP,eAA+B;IAC1D,MAAM,EAAEQ,WAAU,EAAE,GAAGR,aAAaI,MAAM,CAACK,aAAa;IACxD,MAAM,EAAEC,OAAOC,UAAS,EAAE,GAAG,MAAMX,aAAaY,MAAM,CAAC;QAAEC,YAAY;IAAE;IACvE,MAAMC,gBAAgBH,UAAUI,QAAQ,GAAI;IAE5CC,QAAQC,GAAG,CAAC;QAAEN;QAAWH;QAAYM;IAAc;IAEnD,MAAMI,SAASC,SAASC,aAAa,CAAC;IACtCF,OAAOG,KAAK,GAAGV,UAAUW,UAAU;IACnCJ,OAAOK,MAAM,GAAGZ,UAAUa,WAAW;IACrC,MAAMC,gBAAgBP,OAAOQ,UAAU,CAAC;IAExC,MAAMC,cAAc,IAAInC,WAAW;QAC/BoC,SAAS;QACTC,YAAY,IAAI;QAChBC,IAAI,IAAI;QAER,0BAA0B;QAC1BhB;QACAiB,WAAW,OAAOjB;QAElBkB,aAAa,IAAI;QACjBC,cAAc;IAElB;IAEA,MAAMC,kBAAkB,OAAOrB,aAAqB,CAAC,GAAK;QACtD,IAAIA,cAAcL,YAAY;QAE9B,MAAM2B,SAAS,MAAMnC,aAAaY,MAAM,CAAC;YAAEC;QAAW;QACtDY,cAAcW,SAAS,CAAC,GAAG,GAAGlB,OAAOG,KAAK,EAAEH,OAAOK,MAAM;QACzDE,cAAcY,SAAS,CAACF,OAAOzB,KAAK,EAAE,GAAG;QACzCiB,YAAYW,QAAQ,CAACpB;QAErB,MAAMgB,gBAAgBrB,aAAa;IACvC;IAEA,MAAMqB;IAEN,MAAMK,WAAiB,MAAMZ,YAAYa,QAAQ;IACjD,OAAOC,IAAIC,eAAe,CAACH;AAC/B;AAGA,OAAO,SAASI,0BAA0BC,OAKzC,EAAE;IACC,MAAMC,iBAAiB,UAAY;QAC/BD,QAAQE,IAAI,CAACC,SAAS,GAAG;QACzB,MAAMC,YAAY,IAAIC;QAEtB,MAAMvC,QAAQkC,QAAQM,QAAQ;QAC9B,MAAMnD,kBAAkB,MAAMN,qBAAqBiB,MAAMyC,GAAG;QAC5D,MAAMnD,eAAe,MAAMF,mBAAmBC;QAC9C,MAAMqD,cAAc,MAAM7C,gBAAgBP;QAE1C4C,QAAQS,KAAK,CAACF,GAAG,GAAGC;QAEpB,MAAME,UAAU,IAAIL;QACpB,MAAMlC,WAAW,AAACuC,CAAAA,QAAQC,OAAO,KAAKP,UAAUO,OAAO,EAAC,IAAK;QAC7DX,QAAQE,IAAI,CAACC,SAAS,GAAG,CAAC,QAAQ,EAAEhC,SAAS,CAAC,CAAC;IACnD;IAEA6B,QAAQY,MAAM,CAACC,gBAAgB,CAAC,SAASZ,gBAAgB,KAAK;AAClE,CAAC"}