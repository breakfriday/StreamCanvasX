{"version":3,"sources":["./src/services/a.ts"],"sourcesContent":["/* eslint-disable */\nimport { TsDemuxer } from \"./ts-demuxer\";\n\nif (!(\"VideoDecoder\" in window)) {\n  window.alert(\n    \"请开启 chrome://flags/#enable-experimental-web-platform-features\"\n  );\n} else {\n  main();\n}\n\nasync function main() {\n  const isAvcC = false; // avcC 格式还是 AnnexB，false 为 AnnexB 格式\n\n  // 下载 10s 电影片段\n  const response = await fetch(\n    \"https://test-streams.mux.dev/x36xhzz/url_4/url_718/193039199_mp4_h264_aac_7.ts\"\n  );\n  const movie = new Uint8Array(await response.arrayBuffer());\n\n  // demux\n  const tsDemuxer = new TsDemuxer();\n  const avcTrack = tsDemuxer.demux(movie).video;\n\n  // 创建 canvas 用来渲染电影\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = avcTrack.width;\n  canvas.height = avcTrack.height;\n  document.body.appendChild(canvas);\n  const ctx = canvas.getContext(\"2d\");\n  ctx.font = \"30px serif\";\n\n  // VideoDecoder 配置\n  const decoderConfig = {\n    codec: avcTrack.codec\n  };\n\n  if (isAvcC) {\n    decoderConfig.description = AVCDecoderConfigurationRecord(avcTrack);\n  }\n\n  const { config, supported } = await VideoDecoder.isConfigSupported(\n    decoderConfig\n  );\n  console.log(config);\n  if (!supported) {\n    window.alert(`当前设备不支持解码 codec: ${avcTrack.codec}`);\n    return;\n  }\n\n  let frameCount = 0;\n  let startTime;\n  const decoder = new VideoDecoder({\n    output: (frame) => {\n      ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);\n      frame.close();\n\n      const now = performance.now();\n      let fps = \"\";\n      if (frameCount++) {\n        fps = (1000 * (frameCount / (now - startTime))).toFixed(0) + \" FPS\";\n      } else {\n        startTime = now;\n      }\n\n      ctx.fillText(fps, 20, 50);\n    },\n    error: console.error\n  });\n\n  // 配置 VideoDecoder\n  decoder.configure(decoderConfig);\n\n\n  //这段代码从一个H.264流（avcTrack.frames）中读取每一个视频帧，然后将这些帧送入一个视频解码器进行解码。以下是这段代码的详细解释：\n\n  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n  for (let frame of avcTrack.frames) {\n    // 封装成 AnnexB 格式\n    const data = isAvcC ? avcC(frame.units) : AnnexB(frame.units);\n\n    const timestamp = frame.pts / 90000;\n    const duration = frame.duration / 90000;\n\n    const chunk = new EncodedVideoChunk({\n      type: frame.key ? \"key\" : \"delta\",\n      timestamp: timestamp * 1000000, // 微秒\n      duration: duration * 1000000, // 微秒\n      data\n    });\n\n    decoder.decode(chunk);\n\n    await sleep(duration * 1000);\n  }\n}\n\nfunction AnnexB(units) {\n  const size = units.reduce((t, u) => t + u.byteLength, 0) + units.length * 3;\n  const data = new Uint8Array(size);\n\n  let offset = 0;\n  units.forEach((unit) => {\n    data.set([0, 0, 1], offset);\n    offset += 3;\n    data.set(unit, offset);\n    offset += unit.byteLength;\n  });\n\n  return data;\n}\n\nfunction avcC(units) {\n  const size = units.reduce((t, u) => t + u.byteLength, 0) + units.length * 4;\n  const data = new Uint8Array(size);\n  const dataView = new DataView(data.buffer);\n\n  let offset = 0;\n  units.forEach((unit) => {\n    dataView.setUint32(offset, unit.byteLength);\n    offset += 4;\n    data.set(unit, offset);\n    offset += unit.byteLength;\n  });\n\n  return data;\n}\n\nfunction AVCDecoderConfigurationRecord(track) {\n  const sps = [];\n  const pps = [];\n\n  let len;\n  track.sps.forEach((s) => {\n    len = s.byteLength;\n    sps.push((len >>> 8) & 0xff);\n    sps.push(len & 0xff);\n    sps.push(...s);\n  });\n\n  track.pps.forEach((p) => {\n    len = p.byteLength;\n    pps.push((len >>> 8) & 0xff);\n    pps.push(len & 0xff);\n    pps.push(...p);\n  });\n\n  return new Uint8Array(\n    [\n      0x01,\n      track.profileIdc,\n      track.profileCompatibility,\n      track.levelIdc,\n      0xfc | 3,\n      0xe0 | track.sps.length\n    ]\n      .concat(sps)\n      .concat([track.pps.length])\n      .concat(pps)\n  );\n}\n"],"names":["TsDemuxer","window","alert","main","isAvcC","response","fetch","movie","Uint8Array","arrayBuffer","tsDemuxer","avcTrack","demux","video","canvas","document","createElement","width","height","body","appendChild","ctx","getContext","font","decoderConfig","codec","description","AVCDecoderConfigurationRecord","config","supported","VideoDecoder","isConfigSupported","console","log","frameCount","startTime","decoder","output","frame","drawImage","close","now","performance","fps","toFixed","fillText","error","configure","sleep","ms","Promise","r","setTimeout","frames","data","avcC","units","AnnexB","timestamp","pts","duration","chunk","EncodedVideoChunk","type","key","decode","size","reduce","t","u","byteLength","length","offset","forEach","unit","set","dataView","DataView","buffer","setUint32","track","sps","pps","len","s","push","p","profileIdc","profileCompatibility","levelIdc","concat"],"mappings":"AAAA,kBAAkB,GAClB,SAASA,SAAS,QAAQ,eAAe;AAEzC,IAAI,CAAE,CAAA,kBAAkBC,MAAK,GAAI;IAC/BA,OAAOC,KAAK,CACV;AAEJ,OAAO;IACLC;AACF,CAAC;AAED,eAAeA,OAAO;IACpB,MAAMC,SAAS,KAAK,EAAE,qCAAqC;IAE3D,cAAc;IACd,MAAMC,WAAW,MAAMC,MACrB;IAEF,MAAMC,QAAQ,IAAIC,WAAW,MAAMH,SAASI,WAAW;IAEvD,QAAQ;IACR,MAAMC,YAAY,IAAIV;IACtB,MAAMW,WAAWD,UAAUE,KAAK,CAACL,OAAOM,KAAK;IAE7C,mBAAmB;IACnB,MAAMC,SAASC,SAASC,aAAa,CAAC;IACtCF,OAAOG,KAAK,GAAGN,SAASM,KAAK;IAC7BH,OAAOI,MAAM,GAAGP,SAASO,MAAM;IAC/BH,SAASI,IAAI,CAACC,WAAW,CAACN;IAC1B,MAAMO,MAAMP,OAAOQ,UAAU,CAAC;IAC9BD,IAAIE,IAAI,GAAG;IAEX,kBAAkB;IAClB,MAAMC,gBAAgB;QACpBC,OAAOd,SAASc,KAAK;IACvB;IAEA,IAAIrB,QAAQ;QACVoB,cAAcE,WAAW,GAAGC,8BAA8BhB;IAC5D,CAAC;IAED,MAAM,EAAEiB,OAAM,EAAEC,UAAS,EAAE,GAAG,MAAMC,aAAaC,iBAAiB,CAChEP;IAEFQ,QAAQC,GAAG,CAACL;IACZ,IAAI,CAACC,WAAW;QACd5B,OAAOC,KAAK,CAAC,CAAC,iBAAiB,EAAES,SAASc,KAAK,CAAC,CAAC;QACjD;IACF,CAAC;IAED,IAAIS,aAAa;IACjB,IAAIC;IACJ,MAAMC,UAAU,IAAIN,aAAa;QAC/BO,QAAQ,CAACC,QAAU;YACjBjB,IAAIkB,SAAS,CAACD,OAAO,GAAG,GAAGxB,OAAOG,KAAK,EAAEH,OAAOI,MAAM;YACtDoB,MAAME,KAAK;YAEX,MAAMC,MAAMC,YAAYD,GAAG;YAC3B,IAAIE,MAAM;YACV,IAAIT,cAAc;gBAChBS,MAAM,AAAC,CAAA,OAAQT,CAAAA,aAAcO,CAAAA,MAAMN,SAAQ,CAAC,CAAC,EAAGS,OAAO,CAAC,KAAK;YAC/D,OAAO;gBACLT,YAAYM;YACd,CAAC;YAEDpB,IAAIwB,QAAQ,CAACF,KAAK,IAAI;QACxB;QACAG,OAAOd,QAAQc,KAAK;IACtB;IAEA,kBAAkB;IAClBV,QAAQW,SAAS,CAACvB;IAGlB,2EAA2E;IAE3E,MAAMwB,QAAQ,CAACC,KAAO,IAAIC,QAAQ,CAACC,IAAMC,WAAWD,GAAGF;IACvD,KAAK,IAAIX,SAAS3B,SAAS0C,MAAM,CAAE;QACjC,gBAAgB;QAChB,MAAMC,OAAOlD,SAASmD,KAAKjB,MAAMkB,KAAK,IAAIC,OAAOnB,MAAMkB,KAAK,CAAC;QAE7D,MAAME,YAAYpB,MAAMqB,GAAG,GAAG;QAC9B,MAAMC,WAAWtB,MAAMsB,QAAQ,GAAG;QAElC,MAAMC,QAAQ,IAAIC,kBAAkB;YAClCC,MAAMzB,MAAM0B,GAAG,GAAG,QAAQ,OAAO;YACjCN,WAAWA,YAAY;YACvBE,UAAUA,WAAW;YACrBN;QACF;QAEAlB,QAAQ6B,MAAM,CAACJ;QAEf,MAAMb,MAAMY,WAAW;IACzB;AACF;AAEA,SAASH,OAAOD,KAAK,EAAE;IACrB,MAAMU,OAAOV,MAAMW,MAAM,CAAC,CAACC,GAAGC,IAAMD,IAAIC,EAAEC,UAAU,EAAE,KAAKd,MAAMe,MAAM,GAAG;IAC1E,MAAMjB,OAAO,IAAI9C,WAAW0D;IAE5B,IAAIM,SAAS;IACbhB,MAAMiB,OAAO,CAAC,CAACC,OAAS;QACtBpB,KAAKqB,GAAG,CAAC;YAAC;YAAG;YAAG;SAAE,EAAEH;QACpBA,UAAU;QACVlB,KAAKqB,GAAG,CAACD,MAAMF;QACfA,UAAUE,KAAKJ,UAAU;IAC3B;IAEA,OAAOhB;AACT;AAEA,SAASC,KAAKC,KAAK,EAAE;IACnB,MAAMU,OAAOV,MAAMW,MAAM,CAAC,CAACC,GAAGC,IAAMD,IAAIC,EAAEC,UAAU,EAAE,KAAKd,MAAMe,MAAM,GAAG;IAC1E,MAAMjB,OAAO,IAAI9C,WAAW0D;IAC5B,MAAMU,WAAW,IAAIC,SAASvB,KAAKwB,MAAM;IAEzC,IAAIN,SAAS;IACbhB,MAAMiB,OAAO,CAAC,CAACC,OAAS;QACtBE,SAASG,SAAS,CAACP,QAAQE,KAAKJ,UAAU;QAC1CE,UAAU;QACVlB,KAAKqB,GAAG,CAACD,MAAMF;QACfA,UAAUE,KAAKJ,UAAU;IAC3B;IAEA,OAAOhB;AACT;AAEA,SAAS3B,8BAA8BqD,KAAK,EAAE;IAC5C,MAAMC,MAAM,EAAE;IACd,MAAMC,MAAM,EAAE;IAEd,IAAIC;IACJH,MAAMC,GAAG,CAACR,OAAO,CAAC,CAACW,IAAM;QACvBD,MAAMC,EAAEd,UAAU;QAClBW,IAAII,IAAI,CAAC,AAACF,QAAQ,IAAK;QACvBF,IAAII,IAAI,CAACF,MAAM;QACfF,IAAII,IAAI,IAAID;IACd;IAEAJ,MAAME,GAAG,CAACT,OAAO,CAAC,CAACa,IAAM;QACvBH,MAAMG,EAAEhB,UAAU;QAClBY,IAAIG,IAAI,CAAC,AAACF,QAAQ,IAAK;QACvBD,IAAIG,IAAI,CAACF,MAAM;QACfD,IAAIG,IAAI,IAAIC;IACd;IAEA,OAAO,IAAI9E,WACT;QACE;QACAwE,MAAMO,UAAU;QAChBP,MAAMQ,oBAAoB;QAC1BR,MAAMS,QAAQ;QACd,OAAO;QACP,OAAOT,MAAMC,GAAG,CAACV,MAAM;KACxB,CACEmB,MAAM,CAACT,KACPS,MAAM,CAAC;QAACV,MAAME,GAAG,CAACX,MAAM;KAAC,EACzBmB,MAAM,CAACR;AAEd"}