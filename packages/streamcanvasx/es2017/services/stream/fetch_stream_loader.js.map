{"version":3,"sources":["./src/services/stream/fetch_stream_loader.ts"],"sourcesContent":["class httpFlvStreamLoader {\n    private _requestAbort: boolean;\n    constructor() {\n        this.requestAbort = false;\n    }\n    static isSupported() {\n        if (window.fetch && window.ReadableStream) {\n             return true;\n        } else {\n            console.log('Fetch and Stream API are not supported');\n            return false;\n        }\n    }\n    get requestAbort(): boolean {\n        return this._requestAbort;\n    }\n    set requestAbort(value: boolean) {\n        this._requestAbort = value;\n    }\n\n\n    async fetchStream(url: string): Promise<void> {\n        let sourceUrl = url;\n        let headers = new Headers();\n        let params: RequestInit = {\n            method: 'GET',\n            mode: 'cors', // cors is enabled by default\n            credentials: 'same-origin', // withCredentials is disabled by default\n            headers: headers,\n            cache: 'default',\n            referrerPolicy: 'no-referrer-when-downgrade',\n\n        };\n\n        try {\n            const response: Response = await fetch(url, params);\n            if (this.requestAbort === true) {\n                response.body.cancel();\n                return;\n            }\n\n            const reader = response.body?.getReader();\n            if (reader) {\n                await this.processStream(reader);\n            }\n        } catch (e) {\n\n        }\n    }\n\n\n    async processStream(reader: ReadableStreamDefaultReader): Promise<void> {\n        while (true) {\n            try {\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log('Stream complete');\n                    return;\n                }\n\n                // Your process goes here, where you can handle each chunk of FLV data\n                // For example:\n                // this.processFlvChunk(value);\n            } catch (e) {\n                console.error('Error reading stream', e);\n                return;\n            }\n        }\n    }\n\n    processFlvChunk(chunk: Uint8Array): void {\n\n\n    }\n\n    abort() {\n\n    }\n}"],"names":["httpFlvStreamLoader","isSupported","window","fetch","ReadableStream","console","log","requestAbort","_requestAbort","value","fetchStream","url","sourceUrl","headers","Headers","params","method","mode","credentials","cache","referrerPolicy","response","body","cancel","reader","getReader","processStream","e","done","read","error","processFlvChunk","chunk","abort","constructor"],"mappings":";AAAA,MAAMA;IAKF,OAAOC,cAAc;QACjB,IAAIC,OAAOC,KAAK,IAAID,OAAOE,cAAc,EAAE;YACtC,OAAO,IAAI;QAChB,OAAO;YACHC,QAAQC,GAAG,CAAC;YACZ,OAAO,KAAK;QAChB,CAAC;IACL;IACA,IAAIC,eAAwB;QACxB,OAAO,IAAI,CAACC,aAAa;IAC7B;IACA,IAAID,aAAaE,KAAc,EAAE;QAC7B,IAAI,CAACD,aAAa,GAAGC;IACzB;IAGA,MAAMC,YAAYC,GAAW,EAAiB;QAC1C,IAAIC,YAAYD;QAChB,IAAIE,UAAU,IAAIC;QAClB,IAAIC,SAAsB;YACtBC,QAAQ;YACRC,MAAM;YACNC,aAAa;YACbL,SAASA;YACTM,OAAO;YACPC,gBAAgB;QAEpB;QAEA,IAAI;gBAOeC;YANf,MAAMA,WAAqB,MAAMlB,MAAMQ,KAAKI;YAC5C,IAAI,IAAI,CAACR,YAAY,KAAK,IAAI,EAAE;gBAC5Bc,SAASC,IAAI,CAACC,MAAM;gBACpB;YACJ,CAAC;YAED,MAAMC,SAASH,CAAAA,iBAAAA,SAASC,IAAI,cAAbD,4BAAAA,KAAAA,IAAAA,eAAeI;YAC9B,IAAID,QAAQ;gBACR,MAAM,IAAI,CAACE,aAAa,CAACF;YAC7B,CAAC;QACL,EAAE,OAAOG,GAAG,CAEZ;IACJ;IAGA,MAAMD,cAAcF,MAAmC,EAAiB;QACpE,MAAO,IAAI,CAAE;YACT,IAAI;gBACA,MAAM,EAAEI,KAAI,EAAEnB,MAAK,EAAE,GAAG,MAAMe,OAAOK,IAAI;gBACzC,IAAID,MAAM;oBACNvB,QAAQC,GAAG,CAAC;oBACZ;gBACJ,CAAC;YAED,sEAAsE;YACtE,eAAe;YACf,+BAA+B;YACnC,EAAE,OAAOqB,GAAG;gBACRtB,QAAQyB,KAAK,CAAC,wBAAwBH;gBACtC;YACJ;QACJ;IACJ;IAEAI,gBAAgBC,KAAiB,EAAQ,CAGzC;IAEAC,QAAQ,CAER;IA3EAC,aAAc;QADd,uBAAQ1B,iBAAR,KAAA;QAEI,IAAI,CAACD,YAAY,GAAG,KAAK;IAC7B;AA0EJ"}