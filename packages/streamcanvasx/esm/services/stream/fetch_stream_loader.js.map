{"version":3,"sources":["./src/services/stream/fetch_stream_loader.ts"],"sourcesContent":["class httpFlvStreamLoader {\n    private _requestAbort: boolean;\n    constructor() {\n        this.requestAbort = false;\n    }\n    static isSupported() {\n        if (window.fetch && window.ReadableStream) {\n             return true;\n        } else {\n            console.log('Fetch and Stream API are not supported');\n            return false;\n        }\n    }\n    get requestAbort(): boolean {\n        return this._requestAbort;\n    }\n    set requestAbort(value: boolean) {\n        this._requestAbort = value;\n    }\n\n\n    async fetchStream(url: string): Promise<void> {\n        let sourceUrl = url;\n        let headers = new Headers();\n        let params: RequestInit = {\n            method: 'GET',\n            mode: 'cors', // cors is enabled by default\n            credentials: 'same-origin', // withCredentials is disabled by default\n            headers: headers,\n            cache: 'default',\n            referrerPolicy: 'no-referrer-when-downgrade',\n\n        };\n\n        try {\n            const response: Response = await fetch(url, params);\n            if (this.requestAbort === true) {\n                response.body.cancel();\n                return;\n            }\n\n            const reader = response.body?.getReader();\n            if (reader) {\n                await this.processStream(reader);\n            }\n        } catch (e) {\n\n        }\n    }\n\n\n    async processStream(reader: ReadableStreamDefaultReader): Promise<void> {\n        while (true) {\n            try {\n                const { done, value } = await reader.read();\n                if (done) {\n                    console.log('Stream complete');\n                    return;\n                }\n\n                // Your process goes here, where you can handle each chunk of FLV data\n                // For example:\n                // this.processFlvChunk(value);\n            } catch (e) {\n                console.error('Error reading stream', e);\n                return;\n            }\n        }\n    }\n\n    abort() {\n\n    }\n}"],"names":["httpFlvStreamLoader","_requestAbort","requestAbort","value","fetchStream","url","sourceUrl","headers","params","response","reader","e","Headers","method","mode","credentials","cache","referrerPolicy","fetch","body","cancel","getReader","processStream","done","read","console","log","error","abort","isSupported","window","ReadableStream"],"mappings":";;;;;AAAA,IAAA,AAAMA,oCAAN;;aAAMA;gCAAAA;QACF,uBAAQC,iBAAR,KAAA;QAEI,IAAI,CAACC,YAAY,GAAG,KAAK;;kBAH3BF;;YAaEE,KAAAA;iBAAJ,eAA4B;gBACxB,OAAO,IAAI,CAACD,aAAa;YAC7B;iBACA,aAAiBE,KAAc,EAAE;gBAC7B,IAAI,CAACF,aAAa,GAAGE;YACzB;;;YAGMC,KAAAA;mBAAN,SAAMA,YAAYC,GAAW;;uBAA7B,oBAAA,WAA8C;wBACtCC,WACAC,SACAC,QAiBeC,gBANTA,UAMAC,QAIDC;;;;gCAvBLL,YAAYD;gCACZE,UAAU,IAAIK;gCACdJ,SAAsB;oCACtBK,QAAQ;oCACRC,MAAM;oCACNC,aAAa;oCACbR,SAASA;oCACTS,OAAO;oCACPC,gBAAgB;gCAEpB;;;;;;;;;gCAG+B;;oCAAMC,MAAMb,KAAKG;;;gCAAtCC,WAAqB;gCAC3B,IAAI,MAAKP,YAAY,KAAK,IAAI,EAAE;oCAC5BO,SAASU,IAAI,CAACC,MAAM;oCACpB;;;gCACJ,CAAC;gCAEKV,SAASD,CAAAA,iBAAAA,SAASU,IAAI,cAAbV,4BAAAA,KAAAA,IAAAA,eAAeY;qCAC1BX,QAAAA;;;;gCACA;;oCAAM,MAAKY,aAAa,CAACZ;;;gCAAzB;;;;;;;;gCAECC;;;;;;;;;;;gBAGb;;;;YAGMW,KAAAA;mBAAN,SAAMA,cAAcZ,MAAmC;uBAAvD,oBAAA,WAAwE;wBAGpC,MAAhBa,MAAMpB,OASTQ;;;;qCAXN,IAAI;;;;;;;;;;;;gCAEqB;;oCAAMD,OAAOc,IAAI;;;gCAAjB,OAAA,eAAhBD,OAAgB,KAAhBA,MAAMpB,QAAU,KAAVA;gCACd,IAAIoB,MAAM;oCACNE,QAAQC,GAAG,CAAC;oCACZ;;;gCACJ,CAAC;;;;;;gCAKIf;gCACLc,QAAQE,KAAK,CAAC,wBAAwBhB;gCACtC;;;;;;;;;;;;;;gBAGZ;;;;YAEAiB,KAAAA;mBAAAA,SAAAA,QAAQ,CAER;;;;YAnEOC,KAAAA;mBAAP,SAAOA,cAAc;gBACjB,IAAIC,OAAOZ,KAAK,IAAIY,OAAOC,cAAc,EAAE;oBACtC,OAAO,IAAI;gBAChB,OAAO;oBACHN,QAAQC,GAAG,CAAC;oBACZ,OAAO,KAAK;gBAChB,CAAC;YACL;;;WAZE1B"}