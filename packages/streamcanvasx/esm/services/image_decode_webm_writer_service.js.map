{"version":3,"sources":["./src/services/image_decode_webm_writer_service.ts"],"sourcesContent":["import WebMWriter from 'webm-writer';\n\nclass ImageDecoderService {\n  private imageDecoderProcess: ImageDecoder;\n   constructor() {\n    console.log('--');\n   }\n   async createImageDecoder(imageByteStream: ImageBufferSource): Promise<ImageDecoder> {\n  /*\n  ImageDecoder 是一个Web API，它提供了更多对解码图像过程的控制。\n  可以使用它将图像数据（如 ArrayBuffer 或 Blob）解码成可以绘制到 Canvas 上的格式。\n  */\n    const imageDecoder = new ImageDecoder({\n        data: imageByteStream,\n        type: 'image/gif',\n    });\n\n\n    await imageDecoder.tracks.ready;\n    await imageDecoder.completed;\n\n    this.imageDecoderProcess = imageDecoder;\n\n    return imageDecoder;\n    }\n\n    /*\n\n    除了使用 FileReader 的 readAsArrayBuffer 方法外，\n    还可以使用 Blob.arrayBuffer() (File 对象就是一个 Blob 对象) 方法来获得一个 Promise，\n    该 Promise 解析为表示 Blob 数据的 ArrayBuffer。\n\n    */\n    async blobToArrayBuffer(file: Blob) {\n        const arraybuffer = await file.arrayBuffer();\n        return arraybuffer;\n    }\n\n    async fetchImageByteStream(gifURL: string) {\n        const response = await fetch(gifURL);\n        return response.body!;\n    }\n    async decodeGifToWebM(imageDecoder: ImageDecoder) {\n        const { frameCount } = imageDecoder.tracks.selectedTrack!;\n        const { image: headFrame } = await imageDecoder.decode({ frameIndex: 0 });\n        const frameDuration = headFrame.duration! / 1000;\n\n        console.log('--输出帧日志--');\n        console.log({ headFrame, frameCount, frameDuration });\n\n\n        const canvas = document.createElement('canvas');\n        // codedWidth ，codedHeight代表视频帧的编码高度和宽度，这是帧原始的像素维度。\n        canvas.width = headFrame.codedWidth;\n        canvas.height = headFrame.codedHeight;\n        const canvasContext = canvas.getContext('2d')!;\n\n\n        const videoWriter = new WebMWriter({\n            quality: 1, // WebM image quality from 0.0 (worst) to 0.99999 (best), 1.00 (VP8L lossless) is not supported\n            fileWriter: null, // FileWriter in order to stream to a file instead of buffering to memory (optional)\n            fd: null, // Node.js file handle to write to instead of buffering to memory (optional)\n\n            // You must supply one of:\n            frameDuration, // Duration of frames in milliseconds\n            frameRate: 1000 / frameDuration, // Number of frames per second\n\n            transparent: true, // True if an alpha channel should be included in the video\n            alphaQuality: 1, // Allows you to set the quality level of the alpha channel separately.\n            // If not specified this defaults to the same value as `quality`.\n        });\n\n        const writeVideoFrame = async (frameIndex: number = 0) => {\n            if (frameIndex >= frameCount) return;\n\n            const result = await imageDecoder.decode({ frameIndex });\n            canvasContext.clearRect(0, 0, canvas.width, canvas.height);\n            canvasContext.drawImage(result.image, 0, 0);\n            videoWriter.addFrame(canvas);\n\n            await writeVideoFrame(frameIndex + 1);\n        };\n\n        await writeVideoFrame();\n\n        const webMBlob: Blob = await videoWriter.complete();\n        return URL.createObjectURL(webMBlob);\n    }\n\n\n    async getImageDataByByUrl(options: {\n        imgUrl: string;\n    }) {\n        const { imgUrl } = options;\n        const imageData = await this.fetchImageByteStream(imgUrl);\n        return imageData;\n    }\n\n    async getImageDataByFile(file: Blob) {\n        let data = this.blobToArrayBuffer(file);\n        return data;\n    }\n\n    async decoderByData(data: ImageBufferSource) {\n        const startTime = performance.now();\n        const imageDecoder = await this.createImageDecoder(data);\n    }\n\n\n    async getFrameResultByFrameIndex(options: ImageDecodeOptions, imageDecoderPorocss: ImageDecoder): Promise<ImageDecodeResult> {\n        let { frameIndex } = options;\n        const result = await imageDecoderPorocss.decode({ frameIndex });\n        return result;\n    }\n\n    async compose1(options: {\n        imgUrl: string;\n    }) {\n        let imgData = await this.getImageDataByByUrl(options);\n        const startTime = new Date();\n        let imageDecoder = await this.createImageDecoder(imgData);\n        const videoBlobURL = await this.decodeGifToWebM(imageDecoder);\n        const endTime = new Date();\n        const duration_time = (endTime.getTime() - startTime.getTime()) / 1000;\n\n        console.log(`转码用时${duration_time} 秒`);\n        return videoBlobURL;\n    }\n\n    async compose2(options: {\n        imgUrl: string;\n    }) {\n        let imgData = await this.getImageDataByByUrl(options);\n        const startTime = new Date();\n        let imageDecoder = await this.createImageDecoder(imgData);\n\n        let result = this.getFrameResultByFrameIndex({ frameIndex: 0 }, imageDecoder);\n    }\n\n    async renderCanvas(options: {\n        imgUrl: string;\n    }) {\n        const { imgUrl } = options;\n        const imageByteStream = await this.fetchImageByteStream(imgUrl);\n        const imageDecoder = await this.createImageDecoder(imageByteStream);\n\n\n        const { frameCount } = imageDecoder.tracks.selectedTrack!;\n        const { image: headFrame } = await imageDecoder.decode({ frameIndex: 0 });\n        const frameDuration = headFrame.duration! / 1000;\n    }\n}\n\n\nexport { ImageDecoderService };"],"names":["WebMWriter","ImageDecoderService","imageDecoderProcess","console","log","createImageDecoder","imageByteStream","imageDecoder","ImageDecoder","data","type","tracks","ready","completed","blobToArrayBuffer","file","arraybuffer","arrayBuffer","fetchImageByteStream","gifURL","response","fetch","body","decodeGifToWebM","frameCount","headFrame","frameDuration","canvas","canvasContext","videoWriter","writeVideoFrame","webMBlob","selectedTrack","decode","frameIndex","image","duration","document","createElement","width","codedWidth","height","codedHeight","getContext","quality","fileWriter","fd","frameRate","transparent","alphaQuality","result","clearRect","drawImage","addFrame","complete","URL","createObjectURL","getImageDataByByUrl","options","imgUrl","imageData","getImageDataByFile","decoderByData","startTime","performance","now","getFrameResultByFrameIndex","imageDecoderPorocss","compose1","imgData","videoBlobURL","endTime","duration_time","Date","getTime","compose2","renderCanvas"],"mappings":"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"}