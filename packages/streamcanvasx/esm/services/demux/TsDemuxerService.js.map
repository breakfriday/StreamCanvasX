{"version":3,"sources":["./src/services/demux/TsDemuxerService.ts"],"sourcesContent":["// MPEG-2 TS 数据流的解复用 , 转换 mpeg-ts流为h.264视频的类\ninterface IAvcTrack {\n    codec: string;\n    width: number;\n    height: number;\n    profileIdc: number | null;\n    profileCompatibility: number | null;\n    levelIdc: number | null;\n    pps: IUnit[];\n    sps: IUnit[];\n    frames: AvcFrame[];\n}\n\ninterface IUnit {\n    // 这里填写你的 IUnit 结构\n}\n\ninterface IPes {\n    data: IUnit[];\n    pts: number;\n    dts: number;\n}\n\nclass AvcFrame {\n    public units: IUnit[];\n    public frame: boolean;\n    public key: boolean;\n    public duration: number;\n\n    constructor(public pts: number, public dts: number) {\n        this.units = [];\n        this.frame = false;\n        this.key = false;\n        this.duration = 0;\n    }\n}\n\nclass TsDemuxer {\n    prevAvcFrame: AvcFrame | null;\n\n    constructor() {\n        this.prevAvcFrame = null;\n    }\n\n    demux(data: Uint8Array): { video: IAvcTrack } {\n        let pmtId = -1;\n      let avcId = -1;\n\n      let avcPesData = [];\n\n      const avcTrack = {\n        codec: '',\n        width: 0,\n        height: 0,\n        profileIdc: null,\n        profileCompatibility: null,\n        levelIdc: null,\n        pps: [],\n        sps: [],\n        frames: [],\n      };\n\n      for (let start = 0, len = data.length; start < len; start += 188) {\n        if (data[start] !== 0x47) throw new Error('TS packet did not start with 0x47');\n        const payloadUnitStartIndicator = !!(data[start + 1] & 0x40);\n        const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2];\n        const adaptationFiledControl = (data[start + 3] & 0x30) >> 4;\n\n        let offset;\n        if (adaptationFiledControl > 1) {\n          offset = start + 5 + data[start + 4];\n          if (offset === start + 188) continue;\n        } else {\n          offset = start + 4;\n        }\n\n        switch (pid) {\n          case 0:\n            if (payloadUnitStartIndicator) offset += data[offset] + 1;\n            pmtId = ((data[offset + 10] & 0x1f) << 8) | data[offset + 11];\n            break;\n          case pmtId:\n            {\n              if (payloadUnitStartIndicator) offset += data[offset] + 1;\n              const tableEnd =\n                offset +\n                3 +\n                (((data[offset + 1] & 0x0f) << 8) | data[offset + 2]) -\n                4;\n              const programInfoLength =\n                ((data[offset + 10] & 0x0f) << 8) | data[offset + 11];\n              offset += 12 + programInfoLength;\n              while (offset < tableEnd) {\n                const esPid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2];\n                switch (data[offset]) {\n                  case 0x1b:\n                    avcId = esPid;\n                    break;\n                }\n                offset +=\n                  (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5;\n              }\n            }\n            break;\n          case avcId:\n            if (payloadUnitStartIndicator && avcPesData.length) {\n              const pes = TsDemuxer.parsePES(concatUint8Array(...avcPesData));\n              if (pes) {\n                const { units } = parseAnnexBNALus(pes.data);\n                if (units) this.createAvcFrames(avcTrack, units, pes.pts, pes.dts);\n              }\n              avcPesData = [];\n            }\n            avcPesData.push(data.subarray(offset, start + 188));\n            break;\n        }\n      }\n\n      for (\n        let i = 0, l = avcTrack.frames.length, offset = 0, frame, nextFrame;\n        i < l;\n        i++\n      ) {\n        frame = avcTrack.frames[i];\n        nextFrame = avcTrack.frames[i + 1];\n\n        if (nextFrame) {\n          frame.duration = nextFrame.dts - frame.dts;\n        } else {\n          frame.duration = avcTrack.frames[i - 1]?.duration || 0;\n        }\n      }\n\n      return {\n        video: avcTrack,\n      };\n    }\n\n    static parsePES(data: Uint8Array): IPes | undefined {\n        // 省略代码，因为它和你提供的代码基本一样\n    }\n\n    createAvcFrames(track: IAvcTrack, units: IUnit[], pts: number, dts: number): void {\n        // 省略代码，因为它和你提供的代码基本一样\n    }\n\n    static getSyncOffset(data: Uint8Array): number {\n        // 省略代码，因为它和你提供的代码基本一样\n    }\n}\n"],"names":["AvcFrame","pts","dts","units","frame","key","duration","TsDemuxer","prevAvcFrame","demux","data","pmtId","avcId","avcPesData","avcTrack","codec","width","height","profileIdc","profileCompatibility","levelIdc","pps","sps","frames","start","len","length","Error","payloadUnitStartIndicator","pid","adaptationFiledControl","offset","tableEnd","programInfoLength","esPid","pes","parsePES","concatUint8Array","parseAnnexBNALus","createAvcFrames","push","subarray","i","l","nextFrame","video","track","getSyncOffset"],"mappings":"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"}