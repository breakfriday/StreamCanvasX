
let createWebdsp_c = (() => {
  let _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function (moduleArg = {}) {
let Module = moduleArg; let readyPromiseResolve,
readyPromiseReject; Module['ready'] = new Promise((resolve, reject) => { readyPromiseResolve = resolve; readyPromiseReject = reject; }); let moduleOverrides = Object.assign({}, Module); let arguments_ = []; let thisProgram = './this.program'; let quit_ = (status, toThrow) => { throw toThrow; }; let ENVIRONMENT_IS_WEB = typeof window == 'object'; let ENVIRONMENT_IS_WORKER = typeof importScripts == 'function'; let ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string'; let scriptDirectory = ''; function locateFile(path) { if (Module['locateFile']) { return Module['locateFile'](path, scriptDirectory); } return scriptDirectory + path; } let read_,
readAsync,
readBinary,
setWindowTitle; if (ENVIRONMENT_IS_NODE) { let fs = require('fs'); let nodePath = require('path'); if (ENVIRONMENT_IS_WORKER) { scriptDirectory = `${nodePath.dirname(scriptDirectory)}/`; } else { scriptDirectory = `${__dirname}/`; }read_ = (filename, binary) => { filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename); return fs.readFileSync(filename, binary ? undefined : 'utf8'); }; readBinary = filename => { let ret = read_(filename, true); if (!ret.buffer) { ret = new Uint8Array(ret); } return ret; }; readAsync = (filename, onload, onerror, binary = true) => { filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename); fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => { if (err)onerror(err); else onload(binary ? data.buffer : data); }); }; if (!Module['thisProgram'] && process.argv.length > 1) { thisProgram = process.argv[1].replace(/\\/g, '/'); }arguments_ = process.argv.slice(2); quit_ = (status, toThrow) => { process.exitCode = status; throw toThrow; }; Module['inspect'] = () => '[Emscripten Module object]'; } else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) { if (ENVIRONMENT_IS_WORKER) { scriptDirectory = self.location.href; } else if (typeof document != 'undefined' && document.currentScript) { scriptDirectory = document.currentScript.src; } if (_scriptDir) { scriptDirectory = _scriptDir; } if (scriptDirectory.indexOf('blob:') !== 0) { scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1); } else { scriptDirectory = ''; } { read_ = url => { let xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.send(null); return xhr.responseText; }; if (ENVIRONMENT_IS_WORKER) { readBinary = url => { let xhr = new XMLHttpRequest(); xhr.open('GET', url, false); xhr.responseType = 'arraybuffer'; xhr.send(null); return new Uint8Array(xhr.response); }; }readAsync = (url, onload, onerror) => { let xhr = new XMLHttpRequest(); xhr.open('GET', url, true); xhr.responseType = 'arraybuffer'; xhr.onload = () => { if (xhr.status == 200 || xhr.status == 0 && xhr.response) { onload(xhr.response); return; }onerror(); }; xhr.onerror = onerror; xhr.send(null); }; }setWindowTitle = title => document.title = title; } else {} let out = Module['print'] || console.log.bind(console); let err = Module['printErr'] || console.error.bind(console); Object.assign(Module, moduleOverrides); moduleOverrides = null; if (Module['arguments'])arguments_ = Module['arguments']; if (Module['thisProgram'])thisProgram = Module['thisProgram']; if (Module['quit'])quit_ = Module['quit']; let wasmBinary; if (Module['wasmBinary'])wasmBinary = Module['wasmBinary']; let noExitRuntime = Module['noExitRuntime'] || true; if (typeof WebAssembly != 'object') { abort('no native wasm support detected'); } let wasmMemory; let wasmExports; let ABORT = false; let EXITSTATUS; let HEAP8,
HEAPU8,
HEAP16,
HEAPU16,
HEAP32,
HEAPU32,
HEAPF32,
HEAPF64; function updateMemoryViews() { let b = wasmMemory.buffer; Module['HEAP8'] = HEAP8 = new Int8Array(b); Module['HEAP16'] = HEAP16 = new Int16Array(b); Module['HEAP32'] = HEAP32 = new Int32Array(b); Module['HEAPU8'] = HEAPU8 = new Uint8Array(b); Module['HEAPU16'] = HEAPU16 = new Uint16Array(b); Module['HEAPU32'] = HEAPU32 = new Uint32Array(b); Module['HEAPF32'] = HEAPF32 = new Float32Array(b); Module['HEAPF64'] = HEAPF64 = new Float64Array(b); } let wasmTable; let __ATPRERUN__ = []; let __ATINIT__ = []; let __ATPOSTRUN__ = []; let runtimeInitialized = false; function preRun() { if (Module['preRun']) { if (typeof Module['preRun'] == 'function')Module['preRun'] = [Module['preRun']]; while (Module['preRun'].length) { addOnPreRun(Module['preRun'].shift()); } }callRuntimeCallbacks(__ATPRERUN__); } function initRuntime() { runtimeInitialized = true; callRuntimeCallbacks(__ATINIT__); } function postRun() { if (Module['postRun']) { if (typeof Module['postRun'] == 'function')Module['postRun'] = [Module['postRun']]; while (Module['postRun'].length) { addOnPostRun(Module['postRun'].shift()); } }callRuntimeCallbacks(__ATPOSTRUN__); } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb); } function addOnInit(cb) { __ATINIT__.unshift(cb); } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb); } let runDependencies = 0; let runDependencyWatcher = null; let dependenciesFulfilled = null; function addRunDependency(id) { runDependencies++; if (Module['monitorRunDependencies']) { Module['monitorRunDependencies'](runDependencies); } } function removeRunDependency(id) { runDependencies--; if (Module['monitorRunDependencies']) { Module['monitorRunDependencies'](runDependencies); } if (runDependencies == 0) { if (runDependencyWatcher !== null) { clearInterval(runDependencyWatcher); runDependencyWatcher = null; } if (dependenciesFulfilled) { let callback = dependenciesFulfilled; dependenciesFulfilled = null; callback(); } } } function abort(what) { if (Module['onAbort']) { Module['onAbort'](what); }what = `Aborted(${what})`; err(what); ABORT = true; EXITSTATUS = 1; what += '. Build with -sASSERTIONS for more info.'; let e = new WebAssembly.RuntimeError(what); readyPromiseReject(e); throw e; } let dataURIPrefix = 'data:application/octet-stream;base64,'; function isDataURI(filename) { return filename.startsWith(dataURIPrefix); } function isFileURI(filename) { return filename.startsWith('file://'); } let wasmBinaryFile; wasmBinaryFile = 'webdsp_c.wasm'; if (!isDataURI(wasmBinaryFile)) { wasmBinaryFile = locateFile(wasmBinaryFile); } function getBinarySync(file) { if (file == wasmBinaryFile && wasmBinary) { return new Uint8Array(wasmBinary); } if (readBinary) { return readBinary(file); } throw 'both async and sync fetching of the wasm failed'; } function getBinaryPromise(binaryFile) { if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) { if (typeof fetch == 'function' && !isFileURI(binaryFile)) { return fetch(binaryFile, { credentials: 'same-origin' }).then(response => { if (!response['ok']) { throw `failed to load wasm binary file at '${binaryFile}'`; } return response['arrayBuffer'](); }).catch(() => getBinarySync(binaryFile)); } else if (readAsync) { return new Promise((resolve, reject) => { readAsync(binaryFile, response => resolve(new Uint8Array(response)), reject); }); } } return Promise.resolve().then(() => getBinarySync(binaryFile)); } function instantiateArrayBuffer(binaryFile, imports, receiver) { return getBinaryPromise(binaryFile).then(binary => WebAssembly.instantiate(binary, imports)).then(instance => instance).then(receiver, reason => { err(`failed to asynchronously prepare wasm: ${reason}`); abort(reason); }); } function instantiateAsync(binary, binaryFile, imports, callback) { if (!binary && typeof WebAssembly.instantiateStreaming == 'function' && !isDataURI(binaryFile) && !isFileURI(binaryFile) && !ENVIRONMENT_IS_NODE && typeof fetch == 'function') { return fetch(binaryFile, { credentials: 'same-origin' }).then(response => { let result = WebAssembly.instantiateStreaming(response, imports); return result.then(callback, (reason) => { err(`wasm streaming compile failed: ${reason}`); err('falling back to ArrayBuffer instantiation'); return instantiateArrayBuffer(binaryFile, imports, callback); }); }); } return instantiateArrayBuffer(binaryFile, imports, callback); } function createWasm() { let info = { a: wasmImports }; function receiveInstance(instance, module) { let { exports } = instance; wasmExports = exports; wasmMemory = wasmExports['b']; updateMemoryViews(); wasmTable = wasmExports['m']; addOnInit(wasmExports['c']); removeRunDependency('wasm-instantiate'); return exports; }addRunDependency('wasm-instantiate'); function receiveInstantiationResult(result) { receiveInstance(result['instance']); } if (Module['instantiateWasm']) { try { return Module['instantiateWasm'](info, receiveInstance); } catch (e) { err(`Module.instantiateWasm callback failed with error: ${e}`); readyPromiseReject(e); } }instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject); return {}; } var callRuntimeCallbacks = callbacks => { while (callbacks.length > 0) { callbacks.shift()(Module); } }; let getHeapMax = () => 2147483648; let growMemory = size => { let b = wasmMemory.buffer; let pages = size - b.byteLength + 65535 >>> 16; try { wasmMemory.grow(pages); updateMemoryViews(); return 1; } catch (e) {} }; let _emscripten_resize_heap = requestedSize => { let oldSize = HEAPU8.length; requestedSize >>>= 0; let maxHeapSize = getHeapMax(); if (requestedSize > maxHeapSize) { return false; } let alignUp = (x, multiple) => x + (multiple - x % multiple) % multiple; for (let cutDown = 1; cutDown <= 4; cutDown *= 2) { let overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296); let newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536)); let replacement = growMemory(newSize); if (replacement) { return true; } } return false; }; var wasmImports = { a: _emscripten_resize_heap }; let asm = createWasm(); let ___wasm_call_ctors = () => (___wasm_call_ctors = wasmExports['c'])(); var _grayScale = Module['_grayScale'] = (a0, a1) => (_grayScale = Module['_grayScale'] = wasmExports['d'])(a0, a1); var _brighten = Module['_brighten'] = (a0, a1, a2) => (_brighten = Module['_brighten'] = wasmExports['e'])(a0, a1, a2); var _invert = Module['_invert'] = (a0, a1) => (_invert = Module['_invert'] = wasmExports['f'])(a0, a1); var _noise = Module['_noise'] = (a0, a1) => (_noise = Module['_noise'] = wasmExports['g'])(a0, a1); var _multiFilter = Module['_multiFilter'] = (a0, a1, a2, a3, a4, a5, a6) => (_multiFilter = Module['_multiFilter'] = wasmExports['h'])(a0, a1, a2, a3, a4, a5, a6); var _sobelFilter = Module['_sobelFilter'] = (a0, a1, a2, a3) => (_sobelFilter = Module['_sobelFilter'] = wasmExports['i'])(a0, a1, a2, a3); var _convFilter = Module['_convFilter'] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (_convFilter = Module['_convFilter'] = wasmExports['j'])(a0, a1, a2, a3, a4, a5, a6, a7, a8); let ___errno_location = () => (___errno_location = wasmExports['__errno_location'])(); var _malloc = Module['_malloc'] = a0 => (_malloc = Module['_malloc'] = wasmExports['k'])(a0); var _free = Module['_free'] = a0 => (_free = Module['_free'] = wasmExports['l'])(a0); let calledRun; dependenciesFulfilled = function runCaller() { if (!calledRun)run(); if (!calledRun)dependenciesFulfilled = runCaller; }; function run() { if (runDependencies > 0) { return; }preRun(); if (runDependencies > 0) { return; } function doRun() { if (calledRun) return; calledRun = true; Module['calledRun'] = true; if (ABORT) return; initRuntime(); readyPromiseResolve(Module); if (Module['onRuntimeInitialized'])Module['onRuntimeInitialized'](); postRun(); } if (Module['setStatus']) { Module['setStatus']('Running...'); setTimeout(() => { setTimeout(() => { Module['setStatus'](''); }, 1); doRun(); }, 1); } else { doRun(); } } if (Module['preInit']) { if (typeof Module['preInit'] == 'function')Module['preInit'] = [Module['preInit']]; while (Module['preInit'].length > 0) { Module['preInit'].pop()(); } }run();


  return moduleArg.ready;
}

);
})();
if (typeof exports === 'object' && typeof module === 'object') module.exports = createWebdsp_c;
else if (typeof define === 'function' && define['amd']) define([], () => createWebdsp_c);
